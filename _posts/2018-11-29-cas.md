---
layout: post
title: "Java CAS原理分析"
categories: Java
tags: CAS concurrent 乐观锁
author: zch
---

* content
{:toc}
CAS 全称是 compare and swap，即比较并交换，它是一种原子操作，同时 CAS 是一种乐观机制。java.util.concurrent 包很多功能都是建立在 CAS 之上。











## 如何解决并发安全问题

在我们认识 CAS 之前，我们是通过什么来解决并发带来的安全问题呢？volatile 关键字可以保证变量的可见性，但保证不了原子性，synchronized 关键字利用 JVM 字节码层面来实现同步机制，它是一个悲观锁机制。

```java
public class AddTest {
  public volatile int i;
  public void add() {
    i++;
  }
}
```

通过`javap -c AddTest`看看 add 方法的字节码指令：

```java
public void add();
    Code:
       0: aload_0
       1: dup
       2: getfield      #2                  // Field i:I
       5: iconst_1
       6: iadd
       7: putfield      #2                  // Field i:I
      10: return
```

`i++`被拆分成了几个指令：

1. 执行`getfield`拿到原始 i；
2. 执行`iadd`进行加 1 操作；
3. 执行`putfield`写把累加后的值写回 i。

当线程 1 执行到加 1 步骤时，由于还没有执行赋值改变变量的值，这时候并不会刷新主内存区中的变量，如果此时线程 2 正好要拷贝该变量的值到自己私有缓存中，问题就出现了，当线程 2 拷贝完以后，线程1正好执行赋值运算，立马更新主内存区的值，那么此时线程 2 的副本就是旧的了，脏读又出现了。

怎么解决这个问题呢？

在 add 方法加上 synchronized 修饰解决。

```java
public class AddTest {
  public volatile int i;
  public synchronized void add() {
    i++;
  }
}
```

现在完美解决了并发安全问题了，但是这样做性能也会大打折扣。

下面我们来看看 JDK 自带的 CAS 方案。





## CAS 底层原理

CAS 的思想很简单：**三个参数，一个当前内存值 V、旧的预期值 A、即将更新的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做，并返回 false**。

我们拿 AtomicInteger 类来分析，先来看看 AtomicInteger 静态代码块片段：

```java
public class AtomicInteger extends Number implements java.io.Serializable {
  private static final long serialVersionUID = 6214790243416807050L;

  // setup to use Unsafe.compareAndSwapInt for updates
  private static final Unsafe unsafe = Unsafe.getUnsafe();
  private static final long valueOffset;

  static {
    try {
      valueOffset = unsafe.objectFieldOffset
        (AtomicInteger.class.getDeclaredField("value"));
    } catch (Exception ex) { throw new Error(ex); }
  }

  private volatile int value;
  
  // 省略部分代码
}
```

这里用到了 sun.misc.Unsafe 类，它可以提供硬件级别的原子操作，它可以获取某个属性在内存中的位置，也可以修改对象的字段值，只不过该类对一般开发而言，很少会用到，其底层是用 C/C++ 实现的，所以它的方式都是被 native 关键字修饰过的。

可以看得出 AtomicInteger 类存储的值是在 value 字段中，并且获取了 Unsafe 实例，在静态代码块中，还获取了 value 字段在内存中的偏移量 valueOffset。



接下来我们看个例子：

```java
public class AddIntTest {
  public AtomicInteger i;
  public void add() {
    i.getAndIncrement();
  }
}
```

如上，getAndIncrement() 方法底层利用 CAS 技术保证了并发安全。

```java
public final int getAndIncrement() {
  return unsafe.getAndAddInt(this, valueOffset, 1);
}
```

getAndAddInt 方法：

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
  int var5;
  do {
    var5 = this.getIntVolatile(var1, var2);
  } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));// 自旋
  return var5;
}
```

var5 通过 `this.getIntVolatile(var1, var2)`方法获取，是个 native 方法，其目的是获取 var1 在 var2 偏移量的值，其中 var1 就是 AtomicInteger， var2 是 valueOffset 值。

那么 CAS 核心重点来了，compareAndSwapInt 方法就是实现 CAS 的核心方法，其原理是如果 var1 中的 value 值和 var5 相等，就证明没有其他线程改变过这个变量，那么就把 value 值更新为 `var5 + var4`，其中 var4 是更新的增量值；反之如果没有更新，那么 CAS 就一直采用自旋的方式继续进行操作（其实就是个 while 循环），这一步也是一个原子操作。

分析步骤：

1. 假设 AtomicInteger 里面的 value 原始值为 3，即主内存中 AtomicInteger 的 value 为 3，根据 Java 内存模型，线程 A 和线程 B 各自持有一份 value的副本，值为 3。
2. 线程 A 通过`getIntVolatile(var1, var2)`拿到 value 值 3，这时线程 A 刚好被挂起。
3. 线程 B 也通过`getIntVolatile(var1, var2)`方法获取到 value 值 3，运气好，线程 B 没有被挂起，并执行`compareAndSwapInt`方法比较内存值也为 3，成功修改内存值为 2。
4. 这时线程 A 恢复，执行`compareAndSwapInt`方法比较，发现自己手里的值 3 和内存的值 2 不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。
5. 重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行`compareAndSwapInt`进行比较替换，直到成功。



compareAndSwapInt 方法是一个本地方法：

```java
public final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);
```

Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的。Java 代码需通过 JNI 才能调用，位于 unsafe.cpp，查看源码：

```c++
UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper("Unsafe_CompareAndSwapInt");
  oop p = JNIHandles::resolve(obj);
  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);
  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;
UNSAFE_END
```

**其实我并没有看懂这段代码的意思（内心崩溃）**，网上查阅之后，大概知道如下意思：

1. 先想办法拿到变量 value 在内存中的地址。
2. 通过`Atomic::cmpxchg`实现比较替换，其中参数 x 是即将更新的值，参数 e 是原内存的值。









## CAS 常见问题



### ABA 问题



用AtomicStampedReference处理







### 自旋问题



长时间原地自旋会给CPU带来非常大的执行开销。



