---
layout: post
title: "Java并发之AQS队列同步器"
categories: Java
tags: Concurrent AQS CAS
author: zch
---

* content
{:toc}
AQS 全称是 AbstractQueuedSynchronizer，顾名思义，是一个用来构建锁和同步器的框架，它底层用了 CAS 技术来保证操作的原子性，同时运用了 CLH 同步队列作同步器，这也是 ReentrantLock 公平锁的底层实现机制。它能够成为实现大部分同步需求的基础，也是 J.U.C 并发包同步的核心基础组件。

说是框架，其实就是一个普通的类，它是 Doug Lea 大神的杰作，下面让我们一起学习 Doug Lea 大神是如何用一个普通类就玩转 CAS 解决并发安全问题。













## AQS 简介

之前我有介绍过 CAS 原理，AQS 就是建立在它的基础之上，增加了大量的实现细节，例如获取同步状态、FIFO同步队列等。



直接定位到类`java.util.concurrent.locks.AbstractQueuedSynchronizer`，看到类里面有很多注释，我主要将 AQS 类的几个重要字段与方法列出来：

```java
public abstract class AbstractQueuedSynchronizer
  extends AbstractOwnableSynchronizer
    implements java.io.Serializable {

    private transient volatile Node head;

    private transient volatile Node tail;

    private volatile int state;

    protected final boolean compareAndSetState(int expect, int update) {
        // See below for intrinsics setup to support this
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
    }

    // ...

 }
```





## CLH 同步队列





```java
static final class Node {
  static final Node SHARED = new Node();
  static final Node EXCLUSIVE = null;
  static final int CANCELLED = 1;
  static final int SIGNAL = -1;
  static final int CONDITION = -2;
  static final int PROPAGATE = -3;
  volatile int waitStatus;

  volatile Node prev;
  volatile Node next;
  volatile Thread thread;
  Node nextWaiter;

}
```

用大神的注释来形象地描述一下队列的模型：

```java
/**
  * <pre>
  *      +------+  prev +-----+       +-----+
  * head |      | <---- |     | <---- |     |  tail
  *      +------+       +-----+       +-----+
  * </pre>
  */
```

每个节点都有一个 waitStatus 等待状态，



## 锁



### 获取锁









### 释放锁







### 非公平锁与公平锁
























